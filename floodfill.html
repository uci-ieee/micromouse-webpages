<!DOCTYPE html>
<html lang="en" dir="ltr" data-bs-theme="light">

<head>
	<meta charset="utf-8" name="viewport" content="width=device-width, initial-scale=1">
	<!--Title-->
	<title>Open Project Space</title>
	<!--Favicon-->
	<link rel="icon" href="./assets/images/ops_logo_favicon.png">
	<!--Roboto Font CDN-->
	<link rel="preconnect" href="https://fonts.gstatic.com">
	<link href="https://fonts.googleapis.com/css2?family=Roboto" rel="stylesheet">
	<!--Beckman Font CDN-->
	<link href="https://fonts.cdnfonts.com/css/beckman" rel="stylesheet">
	<!-- Custom Stylesheet "custom.css" used for Bootstrap 5.3.0 css-->
	<link rel="stylesheet" href="./css/custom.css" type="text/css">
	<!-- Popper JS v2.11.8 (Bootstrap Dependency) CDN -->
	<script src="https://cdn.jsdelivr.net/npm/@popperjs/core@2.11.8/dist/umd/popper.min.js"
		integrity="sha384-I7E8VVD/ismYTF4hNIPjVp/Zjvgyol6VFvRkX/vR+Vc4jQkC+hVqc2pM8ODewa9r"
		crossorigin="anonymous"></script>
	<!-- Bootstrap JS v5.3.0 CDN -->
	<script src="https://cdn.jsdelivr.net/npm/bootstrap@5.3.0/dist/js/bootstrap.min.js"
		integrity="sha384-fbbOQedDUMZZ5KreZpsbe1LCZPVmfTnH7ois6mU1QK+m14rQ1l2bGBq41eYeM/fS"
		crossorigin="anonymous"></script>
	<!-- Bootstrap Icons CSS v1.10.0 CDN-->
	<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap-icons@1.10.0/font/bootstrap-icons.css">
	<!-- Highlight JS v11.7.0-->
	<link rel="stylesheet" href="./css/highlight.js/default.min.css" type="text/css">
	<link rel="stylesheet" href="./css/highlight.js/arduino-light.min.css" type="text/css">
	<script src="./js/highlight.min.js"></script>
	<script>hljs.highlightAll();</script>
</head>

<body style="">
	<!-- ======= Header ======= -->
	<script src="./js/ops_header.js"></script>
	<!-- End Header -->

	<div class="container-xl pj-layout my-5">
		<!-- ======= Sidebar ======= -->
		<aside class="pj-sidebar ">
			<nav id="project-toc" class="pj-toc d-flex flex-column px-2 pt-2 pb-4">
				<ul class="nav flex-column">
					<h5 class="mt-2 mb-2 mx-3">Contents</h5>
					<li class="nav-item">
						<a class="nav-link" href="#pj-heading-introduction">Overview</a>
					</li>
					<li class="nav-item">
						<a class="nav-link" href="#pj-heading-concepts">Concepts</a>
						<ul class="nav">
							<li class="nav-item">
								<a class="nav-link"
									href="#pj-heading-concepts-breadboards">Breadboard</a>
							</li>
							<li class="nav-item">
								<a class="nav-link"
									href="#pj-heading-concepts-ohms-law">Ohm's
									Law</a>
							</li>
							<li class="nav-item">
								<a class="nav-link"
									href="#pj-heading-concepts-resistor">Resistor</a>
							</li>
							<li class="nav-item">
								<a class="nav-link"
									href="#pj-heading-concepts-led">LED</a>
							</li>
							<li class="nav-item">
								<a class="nav-link"
									href="#pj-heading-concepts-slide-switch">Slide
									Switch</a>
							</li>
							<li class="nav-item">
								<a class="nav-link"
									href="#pj-heading-concepts-soldering">Soldering</a>
							</li>
						</ul>
					<li class="nav-item">
						<a class="nav-link" href="#pj-heading-requirements">Requirements</a>
					</li>
					<li class="nav-item">
						<a class="nav-link" href="#pj-heading-parts">Parts</a>
					</li>
					<li class="nav-item">
						<a class="nav-link" href="#pj-heading-schematics">Schematics</a>
					</li>
					<li class="nav-item">
						<a class="nav-link" href="#pj-heading-instructions">Instructions</a>
						<ul class="nav">
							<li class="nav-item">
								<a class="nav-link"
									href="#pj-heading-checkpoint1">Checkpoint 1</a>
							</li>
							<li class="nav-item">
								<a class="nav-link"
									href="#pj-heading-checkpoint2">Checkpoint 2</a>
							</li>
							<li class="nav-item">
								<a class="nav-link"
									href="#pj-heading-checkpoint3">Checkpoint 3</a>
							</li>
						</ul>
					</li>
					<li class="nav-item">
						<a class="nav-link" href="#pj-heading-deliverables">Deliverables</a>
					</li>
				</ul>
			</nav>
		</aside>
		<!-- End Sidebar -->

		<main class="pj-main p-3" data-bs-spy="scroll" data-bs-target="#project-toc"
			data-bs-root-margin="0px 0px -40%" data-bs-smooth-scroll="true" tabindex="0">
			<div class="d-flex flex-row justify-content-between mb-5">
				<div class="">
					<h4>Project 1</h4>
					<h1 class="fw-bold">Floodfill</h1>
				</div>
				<div class="alert alert-light" role="alert">
					<i class="bi bi-calendar-event me-1"></i>
					Updated 2025.7.19 <br>
					By Adam Wu
				</div>
			</div>


			<h2 class="mb-3 fw-bold" id="pj-heading-introduction">Overview</h2>
			<p class="mb-3">
				To solve the maze, our mouse needs to be able to navigate to the center of a 16x16 maze.
				We want to do this as efficiently as possible and achieve the best possible time, so we
				need an algorithm to find the shortest path, given any maze with any configuration of
				walls.
			</p>
			<p class="mb-3">
				This may seem very difficult, but using an algorithm called floodfill we can
				confidently chart out the shortest path from any given point to any other given point on
				the maze. Floodfill is the most popular algorithm used in the Micromouse competition. If
				the mouse knows where every single wall is, using floodfill it will always be able to
				find the shortest path to the goal cell. You will find as you progress in micromouse
				that the hard part isn’t finding the shortest path, but rather discovering enough of the
				maze to create an accurate representation. We won’t cover that for now, but keep that in
				mind as you think about how you wish to improve upon the guidelines we provide in this
				course.
			</p>

			<h2 class="mb-4 fw-bold" id="heading-intuition">Intuition</h2>

			<div class="mb-5">
				<p class="mb-2">
					Before we explore the specifics of the algorithm, it’s important to have a
					high-level understanding of how it works. As indicated by its name, a good way
					to visualize the Floodfill algorithm is by imagining a flood expanding out from
					your goal position. Imagine a bucket of water being placed in the center cell of
					a 16 x 16 maze. Immediately, it would spill out and expand to other cells.
					However if there were a wall, it would stop the water from flowing, redirecting
					it elsewhere. If there is enough water being added to the goal cell, eventually
					the entire maze will be filled with water (unless there are closed areas).
				</p>
				<img class="img-fluid m-auto ms-lg-3 my-3 me-lg-5 me-lg-3 float-lg-end"
					src="./assets/images/floodfill/minecraft_flood.gif">
			</div>
			<p class="mb-3">
				So far, this scenario doesn’t seem to be very helpful for maze-solving but now imagine
				that we have observers watching the maze, recording how long it takes for each cell to
				get wet. By referencing these times, we now know the relative distance from any given
				cell to our goal position. For example, a cell immediately adjacent to our goal position
				would have gotten wet immediately, but it would take much longer for the water to travel
				to a cell in the corner. This is the intuition behind Floodfill: starting at the goal
				position and spreading out to adjacent non-blocked cells, assigning ever increasing
				distances to each iteration of cells, until the entire maze is filled. The result should
				be something like this:

			</p>
			<img class="pj-img-fluid mx-auto mb-5" src="./assets/images/floodfill/numbered_maze.png" width="500">
			<p class="mb-2">
				Now that we understand the intuition behind Floodfill, let’s look at a pseudocode
				representation of the algorithm, then dive into each part.
				<pre class="mb-5">
					<code class="pj-code"
					style="white-space: pre-wrap; height:45vh;">
	def floodfill():
		queue.append[goal_cell]
		while not queue.is_empty:
			for cell in get_neighbors(queue.head):
					if cell is_not_blocked:
						cell.distance = curr_distance
						queue.append[cell]
					queue.remove_cell(cell)
				curr_distance++

					</code>
				</pre>
			</p>
				<p class="mb-2">
					That’s it! At its core, floodfill is a very simple algorithm, and with only a few lines we can implement the behavior mentioned previously. Put into English, our approach will be to start at the goal cell and continuously iterate through all the neighboring cells that aren’t blocked by walls. These cells are assigned a distance, and then added to the end of the queue. We will keep a counter variable to keep track of the distance from the goal, and we will increment it by one each iteration of the loop. Then we simply repeat the process for every neighboring cell until there are no more cells in the maze. To implement this behavior we will need two modules: a queue and a get_neighbors() function.
				</p>


			<h3 class="mb-3" id="pj-heading-concepts-queue">Queue</h3>
			<p class="mb-5">
				The queue is a basic and very common data structure that every programmer should be familiar with. To visualize a queue, imagine a line for the grocery checkout. If there are many people waiting in line and the cashier becomes available, the person who has been waiting the longest at the front of the line will be the first to leave. This is exactly how a queue (which is just another word for line) works: elements are added to a list, and when we remove elements, the order is maintained and used such that the first-added item will be removed.
			</p>
			<p class="mb-5">
				In C, the most typical and straightforward implementation of a queue is through the use of an array along with a head and a tail pointer. The array will store the elements themselves, and because arrays are ordered, it is able to record the order in which we added them. The head pointer is simply an integer which holds the index of the current oldest/first added item in the queue, and the tail holds the last item. Whenever we add items, we append it to the array and increment the tail pointer. When we remove items, we copy the item at the index specified by the head pointer and then increment the pointer by one. Adding items to the end of the queue is called “pushing” while removing items from the front is called “popping”. When the head and tail pointers are equal, we know there are no items left in the queue. 
			</p>
<!-- End Footer -->
</body>

</html>
